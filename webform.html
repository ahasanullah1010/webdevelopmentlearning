<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    
    <link rel="stylesheet" href="styleform.css">
</head>


<body>
    
    <header>
        <nav>
            <a href="#">Home</a>
            <a href="#">Login</a>
            <a href="#">SignUp</a>
            <a href="#">About</a>
        </nav>
    </header>
<br><br>
    <main>

       <div class="field">
        <img class="imge" src="batpng.png" alt="fgghg">

        <div class="ball"></div>

       </div>


       <div class="prac">


       </div>



       
       <h1>Banglasesh</h1>



       
    </main>
    
    <footer>

    </footer>
    
</body>
</html>



// Binary Search using Recursive function
/*
#include<stdio.h>
int binsrch(int a[],int i, int l, int x)
{
    if(i==l)
    {
        if(x==a[i])
        return i;
        else
        return 0;
    }
    else{
        int mid=(i+l)/2;
        if(x==a[mid])
        {
            return mid;
        }
        else if(x<a[mid])
        {
            return binsrch(a,i,mid-1,x);
        }
        else
        {
            return binsrch(a,mid+1,l,x);
        }
    }
    
}

int main()
{
    int n,i,x;
    printf("Enter the value of n : ");
    scanf("%d",&n);
    int a[n];
    printf("Enter the array elements : ");
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    printf("Enter the value of x :");
    scanf("%d",&x);

    int b=binsrch(a,1,n,x);

    if(b>0)
    {
        printf("%d is finded in this array and its index number is %d",x,b);
    }
    else
    {
        printf("%d is Not found",x);
    }

    return 0;
}

*/









//MaxMin
/*
#include<stdio.h>
int a[100], max,min;

void maxmin(int i, int j)
{
    if(i==j)
    {
        max=a[i];
        min=a[i];
    }
    else if(i==j-1)
    {
        if(a[i]>a[j])
        {
            max=a[i];
            min=a[j];
        }
        else{
            max=a[j];
            min=a[i];
        }
    }
    else{
        int mid=(i+j)/2;
        maxmin(i,mid);
        int max1=max;
        int min1=min;
        maxmin(mid+1,j);

        if(max1>max)
        max=max1;
        if(min1<min)
        min=min1;
    }
}

int main()
{
    int n,i;
    printf("Enter the value of n : ");
    scanf("%d",&n);
    printf("Enter the array elements : ");
    for ( i = 1; i <= n; i++)
    {
        scanf("%d",&a[i]);
    }

    maxmin(1,n);

    printf("MAX : %d and MIN : %d",max,min);
    
    return 0;
}

*/












//Merge Sort
/*
#include<stdio.h>
int a[100], b[100];

void merge(int low, int mid, int high)
{
    int h=low, i=low, j=mid+1;
    while(h<=mid && j<=high)
    {
        if(a[h]<a[j])
        {
            b[i]=a[h];
            h++;
        }
        else{
            b[i]=a[j];
            j++;
        }
        i++;
    }
    if(h>mid)
    {
        for(int k=j; k<=high; k++)
        {
            b[i]=a[k];
            i++;
        }
    }
    else
    {
        for(int k=h; k<=mid; k++)
        {
            b[i]=a[k];
            i++;
        }
        
    }
    for(int k=low; k<=high; k++)
    {
        a[k]=b[k];
    }
}

void mergesort(int low, int high)
{
    if(low<high)
    {
        int mid=(low+high)/2;
        mergesort(low, mid);
        mergesort(mid+1,high);
        merge(low, mid, high);
    }
}

int main()
{
    int i,n;
    printf("Enter the value of n : ");
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }

    mergesort(1,n);

    printf("After the Merge Sort : ");
    for(i=1; i<=n; i++)
    {
        printf("%d  ",a[i]);
    }

    return 0;
}

*/











//Quick Sort
/*
#include<stdio.h>
int a[100];

int partition(int m, int p)
{
    int u=a[m], i=m, j=p;
    do{
        do{
            i++;
        } while(a[i]<u);

        do{j--;}
        while(a[j]>u);

        if(i<j)
        {
            int tem=a[i];
            a[i]=a[j];
            a[j]=tem;
        }
    }
    while(i<j);
    a[m]=a[j];
    a[j]=u;
    return j;
}

void quicksort(int p, int q)
{
    if(p<q)
    {
        int j=partition(p,q+1);
        quicksort(p,j-1);
        quicksort(j+1,q);
    }
}

int main()
{
    int i,n;
    printf("Enter the value of n : ");
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }

    quicksort(1,n);

    printf("After the Quick Sort : ");
    for(i=1; i<=n; i++)
    {
        printf("%d  ",a[i]);
    }

    return 0;
}
*/









//KnapSack Problem
/*

#include<stdio.h>
float p[100],w[100];
void knapsack(int n, int m)
{
    int i,j;
    float x[n],tp=0, u=m;

    for(i=1;i<=n;i++)
    {
        x[i]=0;
    }
    for(i=1;i<=n;i++)
    {
        if(u<w[i])
        {
            break;
        }
        else
        {
            x[i]=1.0;
            tp=tp+p[i];
            u=u-w[i];
        }
    }
    if(i<=n)
    {
        x[i]=u/w[i];
        tp=tp+(p[i]*x[i]);
    }

    for(i=1;i<=n;i++)
    {
        printf("%f ",p[i]);
    }
    printf("\n");
    for(i=1;i<=n;i++)
    {
        printf("%.2f ",x[i]);
    }
printf("\n");
    printf("Maximum profit : %.2f",tp);
}

int main()
{
    int i,j,n,m;
    printf("Enter the value of n : ");
    scanf("%d",&n);
    float r[n],tem;
    printf("Enter profit and weight : \n");
    for(i=1;i<=n;i++)
    {
        scanf("%f%f",&p[i],&w[i]);
        r[i]=p[i]/w[i];
    }
    printf("Enter the value of m : ");
    scanf("%d",&m);

    for(i=1;i<=n;i++)
    {
        for(j=i+1;j<=n;j++)
        {
            if(r[i]<r[j])
            {
                tem=r[i];
                r[i]=r[j];
                r[j]=tem;

                tem=p[i];
                p[i]=p[j];
                p[j]=tem;

                tem=w[i];
                w[i]=w[j];
                w[j]=tem;
            }
        }
    }

    knapsack(n,m);

    return 0;
}

*/










//Job Sequence problem
/*

#include<stdio.h>

int jobsequence(int d[], int j[], int n)
{
    int i,k,r,q;
    d[0]=j[0]=0;
    j[1]=1;
    k=1;
    for(i=2;i<=n;i++)
    {
        r=k;
        while(d[j[r]]>d[i] && d[j[r]]!=r)
        {
            r=r-1;
        }
        if(d[j[r]]<=d[i] && d[i]>r)
        {
            for(q=k;q>=r+1;q--)
            {
                j[q+1]=j[q];
            }
            j[r+1]=i;
            k=k+1;
        }
    }
    return k;
}

int main()
{
    int i,l,n,tem;
    printf("Enter the value of n : ");
    scanf("%d",&n);
    int p[n], d[n], j[n];
    printf("Enter profit : ");
    for(i=1;i<=n;i++)
    {
        scanf("%d",&p[i]);
    }
    printf("Enter deadlines : ");
    for(i=1;i<=n;i++)
    {
        scanf("%d",&d[i]);
    }

    for(i=1;i<=n;i++)
    {
        for(l=i+1;l<=n;l++)
        {
            if(p[i]<p[l])
            {
                tem=p[i];
                p[i]=p[l];
                p[l]=tem;

                tem=d[i];
                d[i]=d[l];
                d[l]=tem;
            }
        }
    }

    int k=jobsequence(d,j,n);
    int maxprofit=0;
    for(i=1;i<=k;i++)
    {
        maxprofit=maxprofit+p[i];
    }
    printf("Maximum profit : %d",maxprofit);

    return 0;
}
*/








// All Pair Shortest Path
/*
#include<stdio.h>
int cost[100][100], a[100][100];

void allpair(int n)
{
    int i,j,k;
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            a[i][j]=cost[i][j];
        }
    }

    for(k=1;k<=n;k++)
    {
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=n;j++)
            {
                if(a[i][j]>a[i][k]+a[k][j])
                {
                    a[i][j]=a[i][k]+a[k][j];
                }
            }
        }
    }
    printf("\n");
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            printf("%d ",a[i][j]);
        }
        printf("\n");
    }

}

int main()
{
    int i,j,n;
    printf("Enter the number of vertes : ");
    scanf("%d",&n);

    printf("Enter the all path length : \n");
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            scanf("%d",&cost[i][j]);
        }
    }

    allpair(n);


    return 0;
}

*/









// Prim's Algorithm

#include <cstring>
#include <iostream>
using namespace std;

#define INF 9999999

#define V 10
int G[V][V] ;

int main() {
  int no_edge;

  int n;
cout<<"Enter the number of node : ";
cin>>n;
  for(int i =0 ;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            cin>>G[i][j];
        }
    }
     int selected[n];
  memset(selected, false, sizeof(selected));


  no_edge = 0;


  selected[0] = true;

  int x;
  int y;

  // printing edge and weight
  cout << "Edge"
     << " : "
     << "Weight";
  cout << endl;
  while (no_edge < n - 1) {
    int min = INF;
    x = 0;
    y = 0;

    for (int i = 0; i < n; i++) {
      if (selected[i]) {
        for (int j = 0; j < n; j++) {
          if (!selected[j] && G[i][j]) {  // not in selected and there is an edge
            if (min > G[i][j]) {
              min = G[i][j];
              x = i;
              y = j;
            }
          }
        }
      }
    }
    cout << x << " - " << y << " :  " << G[x][y];
    cout << endl;
    selected[y] = true;
    no_edge++;
  }

  return 0;
}







//final coloring


#include<bits/stdc++.h>
using namespace std;
int g[20][20],cnt=0,x[50],m,n,c=0;

void NextValue(int k)
{
    while(1)
    {
        x[k]=(x[k]+1)%(m+1);
        if(x[k]==0)
            return;
        int i;
        for(i=1; i<=n; i++)
        {
            if(g[k][i]==1&& x[k]==x[i])
                break;
        }
        if(i==n+1)
            return;
    }
}

void mColoring(int k)
{
    while(1)
    {
        NextValue(k);
        if(x[k]==0)
            return;
        if(k==n)
        {
            c=1;
            for(int i=1; i<=n; i++)
            {
                cout<<" "<<x[i];
            }
            cout<<endl;
            cnt++;
        }
        else mColoring(k+1);
    }
}
int main()
{

    cout<<"Enter the number of nodes : ";
    cin>>n;
    cout<<"Enter the adjacency matrix : "<<endl;
    for(int i=1; i<=n; i++)
    {
        for(int j=1; j<=n; j++)
            cin>>g[i][j];
    }

    cout<<"Possible solutins are :"<<endl;
    for(m=1; m<=n; m++)
    {
        if(c==1)
            break;
        mColoring(1);
    }
    cout<<"The Chromatic number is : "<<m-1<<endl;
    cout<<"The total number of solutions is : "<<cnt<<endl;


    return 0;
}


/*graph = {0, 1, 1, 1},
                         {1, 0, 1, 0},
                         {1, 1, 0, 1},
                         {1, 0, 1, 0}/*/


// Algorithm mColoring(k)
// {
//     repeat
//     {
//         if (x[k] = 0) then return;
//         if (k = n) then write (x[1 : n]);
//         else mColoring(k + 1) ;
//     } until (false);
// }







// n queen
#include<bits/stdc++.h>
using namespace std;
int x[10],cnt=0;;
bool Place(int k,int i)
{
    for(int j=1 ;j<k;j++)
    {
        if((x[j]==i) || (abs(x[j]-i)==abs(j-k)))
            return false;

    } return true;
}

void NQueens(int k,int n)
{
    for(int i=1 ;i<=n;i++)
    {
        if(Place(k,i))
        {
            x[k]=i;
            if(k==n)
            {
                cnt++;
                    cout<<"Solution : "<<cnt<<endl;
                for(int a=1;a<=n;a++)
                {

                    for(int b=1;b<=n;b++)
                    {
                        if(x[a]==b)
                            cout<<"  Q";
                        else cout<<"  -";
                    }cout<<endl;
                }
            }
            else NQueens(k+1,n);
        }
    }


}

int main()
{
        cout<<"Enter the number of queen : ";
        int n;
        cin>>n;
        NQueens(1,n);

    return  0;
}
// Algorithms Nquens(K,n){
//     for i:=1 to n do{
//         if place(k,i) then{
//             x[k]:=i;
//             if(k=n) then write (x[1:n]);
//             else Nquens(k+1,n);
//         }
//     }
// }

// Algorithm place(k,i){
//     for j:=1 to k-1 do{
//         if x[j]=i or abs(x[j]-i)= abs(j-k) then return false
//     }
//     return true
// }







//single source Dijkstra

#include<bits/stdc++.h>

using namespace std;
#define mx 10
int minimumDist(int n,int dist[], bool visited[])
{
	int min=INT_MAX,index;

	for(int i=0;i<n;i++)
	{
		if(visited[i]==false && dist[i]<=min)
		{
			min=dist[i];
			index=i;
		}
	}
	return index;
}

void Dijkstra(int graph[mx][mx],int n,int src)
{
	int dist[mx];
	bool visited[mx];
	for(int i = 0; i<n; i++)
	{
		dist[i] = INT_MAX;
		visited[i] = false;
	}

	dist[src] = 0;
	for(int i = 0; i<n; i++)
	{
		int m=minimumDist(n,dist,visited);
		visited[m]=true;
		for(int i = 0; i<n; i++)
		{
			if(!visited[i] && graph[m][i] && dist[m]!=INT_MAX && dist[m]+graph[m][i]<dist[i])
				dist[i]=dist[m]+graph[m][i];
		}
	}
	cout<<"Vertex\t\tDistance from source"<<endl;
	for(int i = 0; i<n; i++)
	{
		char str=65+i;
		cout<<str<<"\t\t\t"<<dist[i]<<endl;
	}
}

int main()
{
    int n;
    cout<<"enter the number of vertices (maximum 10): "<<endl;
    cin>>n;
    int graph[mx][mx];
    cout<<"enter the weight matrix : ";
    for(int i =0 ;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            cin>>graph[i][j];
        }
    }
    int source;
    cout<<"Enter the source vertex : ";
    cin>>source;

	Dijkstra(graph,n,source);
	return 0;
}









// Minimum cost spanning tree using Krushkal’s algorithm#include<stdio.h>
    #include<bits/stdc++.h>
    using namespace std;
    int i, j, k, a, b, u, v, n, ne = 1;
    int Min, Mincost = 0, cost[9][9], parent[9];
    int find(int);
    int uni(int, int);
    int main()
    {
        printf("\n\tImplementation of Kruskal's algorithm\n");
        printf("\nEnter the no. of vertices:");
        scanf("%d", &n);
        printf("\nEnter the cost adjacency matrix:\n");
        for (i = 1; i <= n; i++)
        {
            for (j = 1; j <= n; j++)
            {
                scanf("%d", &cost[i][j]);
                if (cost[i][j] == 0)
                    cost[i][j] = 999;
            }
        }
        printf("The edges of Minimum Cost Spanning Tree are\n");
        while (ne < n)
        {
            for (i = 1, Min = 999; i <= n; i++)
            {
                for (j = 1; j <= n; j++)
                {
                    if (cost[i][j] < Min)
                    {
                        Min = cost[i][j];
                        a = u = i;
                        b = v = j;
                    }
                }
            }
            u = find(u);
            v = find(v);
            if (uni(u, v))
            {
                printf("%d edge (%d,%d) =%d\n", ne++, a, b, Min);
                Mincost += Min;
            }
            cost[a][b] = cost[b][a] = 999;
        }
        printf("\n\tMinimum cost = %d\n", Mincost);
        // getch();
    }
    int find(int i)
    {
        while (parent[i])
            i = parent[i];
        return i;
    }
    int uni(int i, int j)s
    {
        if (i != j)
        {
            parent[j] = i;
            return 1;
        }
        return 0;
    }